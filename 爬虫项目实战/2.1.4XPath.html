<!DOCTYPE html>
<html>
<head>
	<title>2.1.4XPath</title>
	<meta charset="utf-8">
</head>
<body>
	<h1>2.1.4XPath</h1>
	<p>XPath是一门在XML文档中查找信息的语言，被用于在XML文档中通过元素和属性进行导航。XPath虽然是被设计用来搜寻XML文档，不过它也能很好地在HTML文档中工作，并且大部分浏览器也支持通过XPath来查询节点。</p>
	<hr>
	<div class="1.XPath节点">
		<h2>1.XPath节点</h2>
	<p>在XPath中,XML文档是被用作为节点树来对待的,有七种类型的节点:元素、属性、文本、命名空间、处理指令、注释以及文档（根）节点。树的被称为文档节点或者根节点。以下面的XML文档为例进行说明，文档如下：</p>	
	<xmp>
		<?xml version="1.0" encoding="ISO-8859-1"?>
		<classroom>
			<stduent>
				<id>1001</id>
				<name lang="en">marry</name>
				<age>20</age>
				<country>China</country>
			</stduent>
		</classroom>	
	</xmp>
	<p>上面的XML文档中的节点例子包括：&lt;classroom&gt;(文档节点)、&lt;id&gt;1001&lt;/id&gt;(元素节点)、lang="en"(属性节点)、marry(文本)。</p>
	<p>接着说一下节点关系，包括父（parent）、子（Children）、同胞（Sibling）、先辈（Ancestor）、后代（Descendant）。在上面的文档中：</p>
	<br>
	<ul>
		<li>stduent元素是id、name、age以及country元素的父</li>
		<li>id、name、age以及country元素都是stduent元素的子</li>
		<li>id、name、age以及country元素都是同胞节点，拥有相同的父节点</li>
		<li>name元素的先辈是stduent元素和classroom元素，也就是此节点的父、父的父等</li>
		<li>classroom的后代是id、name、age以及country元素，也就是此节点的子、子的子等</li>
	</ul>
	</div>
	<hr>
	<div class="2.XPath语法">
		<h2>2.XPath语法</h2>
		<p>XPath使用路径表达式来选取XML文档中的节点或者节点集。节点是沿着路径（path）或者步（steps）来选取的。接下来的重点是如何选取节点，下面给出一个XML文档进行分析：</p>
		<xmp>
		<?xml version="1.0" encoding="ISO-8859-1"?>
		<classroom>
			<stduent>
				<id>1001</id>
				<name lang="en">marry</name>
				<age>20</age>
				<country>China</country>
			</stduent>
			<stduent>
				<id>1002</id>
				<name lang="en">jack</name>
				<age>25</age>
				<country>USA</country>
			</stduent>
		</classroom>
		</xmp>
		<p>首先列举一些常用的路径表达式进行节点的选取，如表2-2所示。</p>
		<table width="960" rules="all" border="1">
			<caption align="top">表2-2 路径表达式</caption>
			<tr>
				<th>表达式</th>
				<th>描述</th>
			</tr>
			<tr>
				<td>nodename</td>
				<td>选取此节点的所有子节点</td>
			</tr>
			<tr>
				<td>/</td>
				<td>从根节点选取</td>
			</tr>
			<tr>
				<td>//</td>
				<td>选择任意位置的某个节点</td>
			</tr>
			<tr>
				<td>.</td>
				<td>选取当前节点</td>
			</tr>
			<tr>
				<td>..</td>
				<td>选取当前节点的父节点</td>
			</tr>
			<tr>
				<td>@</td>
				<td>选取属性</td>
			</tr>
		</table>
		<p>通过表2-2中的路径表达式，我们尝试着对上面的文档进行节点选取。以表格的形式进行说明，如表2-3所示。</p>	
		<table width="960" rules="all" border="1">
			<caption>表2.3 节点选取示例</caption>
			<tr>
				<th>实现效果</th>
				<th>路径表达式</th>
			</tr>
			<tr>
				<td>选取classroom元素的所有子节点</td>
				<td>classroom</td>
			</tr>
			<tr>
				<td>选取根元素classroom</td>
				<td>/classroom</td>
			</tr>
			<tr>
				<td>选取属于classroom的子元素的所有student元素</td>
				<td>classroom/student</td>
			</tr>
			<tr>
				<td>选取所有student子元素，而不管它们在文档中的位置</td>
				<td>//student</td>
			</tr>
			<tr>
				<td>选择属于classroom元素的后代的所有student元素，而不管它们位于classroom之下的什么位置</td>
				<td>classroom//student</td>
			</tr>
			<tr>
				<td>选取名为lang的所有属性</td>
				<td>//@lang</td>
			</tr>
		</table>
		<p>上面选取的例子最后实现的效果都是选取了所有符合条件的节点，是否能选取某个特定的节点或者包含某一个指定的值的节点呢？这就需要用到谓语，谓语被嵌在方括号中，接下来通过表格2-4来解释谓语的用法。</p>
		<table width="960" rules="all" border="1">
			<caption>表2-4 谓语示例</caption>
			<tr>
				<th>实现效果</th>
				<th>路径表达式</th>
			</tr>			
			<tr>
				<td>选取classroom子元素的第一个student元素</td>
				<td>/classroom/student[1]</td>
			</tr>
			<tr>
				<td>选取classroom子元素的最后一个student元素</td>
				<td>/classroom/student[last()]</td>
			</tr>
			<tr>
				<td>选取classroom子元素的倒数第二个student元素</td>
				<td>/classroom/student[last()-1]</td>
			</tr>
			<tr>
				<td>选取最前面的两个属于classroom元素的子元素的student元素</td>
				<td>/classroom/student[position()<3]</td>
			</tr>
			<tr>
				<td>选取所有拥有名为lang的属性的name元素</td>
				<td>//name[@lang]</td>				
			</tr>
			<tr>
				<td>选取所有name元素,且这些元素拥有值为en的lang属性</td>
				<td>//name[@lang='en']</td>
			</tr>
			<tr>
				<td>选取classroom元素的所有student元素,且其中的age元素的值须大于20</td>
				<td>/classroom/student[age>20]</td>
			</tr>
			<tr>
				<td>选取classroom元素中的student元素的name元素,且其中的age元素的值须大于20</td>
				<td>/classroom/student[age>20]/name</td>
			</tr>
		</table>
		<p>XPath在进行节点选取的时候可以使用通配符"*"匹配未知的元素,同时使用操作符"|"一次选取多条路径,如表2-5所示</p>
		<table width="960" rules="all" border="1">
			<caption>表2-5 通配符"*"与"|"操作符</caption>
			<tr>
				<th>实现效果</th>
				<th>路径表达式</th>
			</tr>	
			<tr>
				<td>选取classroom元素的所有子元素</td>
				<td>/classroom/*</td>
			</tr>
			<tr>
				<td>选取文档中的所有元素</td>
				<td>//*</td>
			</tr>
			<tr>
				<td>选取所有带属性的name元素</td>
				<td>//name[@*]</td>
			</tr>
			<tr>
				<td>选取student元素的所有name和age元素</td>
				<td>//student/name | //student/age</td>
			</tr>
			<tr>
				<td>选取属于classroom元素的student元素的所有name元素,以及文档中所有的age元素</td>
				<td>/classroom/student/name | //age</td>
			</tr>
		</table>
	</div>
	<hr>
	<div class="3.XPath轴">
		<h2>3.XPath轴</h2>
		<p>轴定义了所选节点与当前节点之间的树关系.在Python爬虫开发中,提取网页中的信息会遇到这种情况:首先提取到一个节点的信息,然后想在在这个节点的基础上提取它的子节点或者父节点,这时候会用到轴的概念.轴的存在会使提取变得更加灵活和准确</p>
		<p>在说轴的用法前,需要了解位置路径表达式中的相对位置路径\绝对位置路径和步的概念,位置路径可以绝对的,也可以是相对的,绝对路径起始于正斜杠(/),而相对路径不会这样,在两种情况中,位置路径均包括一个或者多个步,每个步均被斜杠分割:/step/step/...(绝对位置路径),step/step/...(相对位置路径)</p>
		<p>步包括:轴,节点测试,零个或者多个谓语,用来更深入的提炼所选的节点集,步的语法为:轴名称::节点测试[谓语],表2-6列举了XPath轴中使用的节点集</p>
		<table width="960" rules="all" border="1">
			<caption>表2-6 XPath轴</caption>
			<tr>
				<th>轴名称</th>
				<th>含义</th>
			</tr>
			<tr>
				<td>child</td>
				<td>选取当前节点的所有子元素</td>
			</tr>
			<tr>
				<td>parent</td>
				<td>选取当前节点的父节点</td>
			</tr>
			<tr>
				<td>ancestor</td>
				<td>选取当前节点的所有先辈(父,祖父等)</td>
			</tr>
			<tr>
				<td>ancestor-or-self</td>
				<td>选取当前节点的所有先辈(父,祖父等)以及当前节点本身</td>
			</tr>
			<tr>
				<td>descendant</td>
				<td>选取当前节点的所有后代元素(子,孙等)</td>
			</tr>
			<tr>
				<td>descendant-or-self</td>
				<td>选取当前节点的所有后代元素(子,孙等)以及当前节点本身</td>
			</tr>
			<tr>
				<td>preceding</td>
				<td>选取文档中当前节点的开始标记之前的所有节点</td>
			</tr>
			<tr>
				<td>following</td>
				<td>选取文档中当前节点的结束标记之后的所有节点</td>
			</tr>			
			<tr>
				<td>preceding-sibling</td>
				<td>选取文档中当前节点之前的所有同级节点</td>
			</tr>
			<tr>
				<td>following-sibling</td>
				<td>选取文档中当前节点之后的所有同级节点</td>
			</tr>
			<tr>
				<td>self</td>
				<td>选取当前节点</td>
			</tr>
			<tr>
				<td>attribute</td>
				<td>选取当前节点的所有属性</td>
			</tr>
			<tr>
				<td>namespace</td>
				<td>选取当前节点的所有命名空间节点</td>
			</tr>				
		</table>
		<p>首先给出一个XML文档,实例分析就按照这个文档来进行,文档如下:</p>
		<xmp>
		<?xml version="1.0" encoding="ISO-8859-1"?>
		<classroom>
			<stduent>
				<id>1001</id>
				<name lang="en">marry</name>
				<age>20</age>
				<country>China</country>
			</stduent>
			<stduent>
				<id>1002</id>
				<name lang="en">jack</name>
				<age>25</age>
				<country>USA</country>
			</stduent>
			<teacher>
				<classid>1</classid>
				<name lang="en">tom</name>
				<age>50</age>
				<country>USA</country>
			</teacher>
		</classroom>
		</xmp>
		<p>针对上面的文档进行示例演示,如表2-7所示:</p>
		<table width="960" rules="all" border="1">
			<caption>表2-7 XPath轴示例分析</caption>
			<tr>
				<th>实现效果</th>
				<th>路径表达式</th>
			</tr>
			<tr>
				<td>选取当前classroom节点中子元素的teacher节点</td>
				<td>/classroom/child::teacher</td>
			</tr>
			<tr>
				<td>选取所有id节点的父节点</td>
				<td>//id/parent::*</td>
			</tr>
			<tr>
				<td>选取所有以classid为子节点的祖先节点</td>
				<td>//classid/ancestor::*</td>
			</tr>
			<tr>
				<td>选取classroom节点下的所有后代节点</td>
				<td>/classroom/descendant::*</td>
			</tr>
			<tr>
				<td>选取所有以stduent为父节点的id元素</td>
				<td>//stduent/descendant::id</td>
			</tr>
			<tr>
				<td>选取所有classid元素的祖先节点及本身</td>
				<td>//classid/ancestor-or-self::*</td>				
			</tr>
			<tr>
				<td>选择/classroom/stduent本身及所有后代元素</td>
				<td>/classroom/stduent/descendant-or-self::*</td>
			</tr>
			<tr>
				<td>选取/classroom/teacher之前的所有同级节点,结果就是选择了所有的stduent节点</td>
				<td>/classroom/teacher/preceding-sibling::*</td>
			</tr>
			<tr>
				<td>选取/classroom中第二个stduent之后的所有同级节点,结果就是选择了teacher节点</td>
				<td>/classroom/stduent[2]/following-sibling::*</td>
			</tr>
			<tr>
				<td>选取/classroom/teacher/节点所有之前的节点(除其祖先外),不仅仅是student节点,还有里面的子节点</td>
				<td>/classroom/teacher/preceding::*</td>
			</tr>
			<tr>
				<td>选取/classroom中第二个stduent之后的所有节点,结果就是选择了teacher节点及其子节点</td>
				<td>/classroom/stduent[2]/following::*</td>
			</tr>
			<tr>
				<td>选取stduent节点,单独使用没有什么意思,主要是根其它轴一起使用,如ancestor-or-self,descendant-or-self</td>
				<td>//student/self::*</td>
			</tr>
			<tr>
				<td>选取/classroom/teacher/name节点下的所有属性</td>
				<td>/classroom/teacher/name/attribute::*</td>
			</tr>
		</table>
	</div>
	<hr>
	<div class="4.XPath运算符">
		<h2>4.XPath运算符</h2>
		<p>XPath表达式可返回节点集,字符串,逻辑值以及数字,表2-8列举了可用在XPath表达式中的运算符:</p>
		<table width="960" rules="all" border="1">
			<caption>表2-8 XPath运算符示例分析</caption>
			<tr>
				<th>运算符</th>
				<th>描述</th>
				<th>实例</th>
				<th>含义</th>
			</tr>
			<tr>
				<td>|</td>
				<td>计算两个节点集</td>
				<td>//stduent/name | //stduent/age</td>
				<td>选取student元素的所有name和age元素</td>
			</tr>
			<tr>
				<td>+</td>
				<td>加法</td>
				<td>/classroom/student[age=19+1]</td>
				<td>选取classroom元素的所有student元素,且其中的age元素的值须等于20</td>
			</tr>
			<tr>
				<td>-</td>
				<td>减法</td>
				<td>/classroom/student[age=21-1]</td>
				<td>同上</td>
			</tr>
			<tr>
				<td>*</td>
				<td>乘法</td>
				<td>/classroom/student[age=4*5]</td>
				<td>同上</td>
			</tr>
			<tr>
				<td>div</td>
				<td>除法</td>
				<td>/classroom/student[age=40 div 2]</td>
				<td>同上</td>
			</tr>
			<tr>
				<td>=</td>
				<td>等于</td>
				<td>/classroom/student[age=20]</td>
				<td>同上</td>
			</tr>	
			<tr>
				<td>!=</td>
				<td>不等于</td>
				<td>/classroom/student[age!=20]</td>
				<td>选取classroom元素的所有student元素,且其中的age元素的值须不等于20</td>
			</tr>		
			<tr>
				<td>&lt;</td>
				<td>小于</td>
				<td>/classroom/student[age<20]</td>
				<td>选取classroom元素的所有student元素,且其中的age元素的值须小于20</td>
			</tr>
			<tr>
				<td><=</td>
				<td>小于等于</td>
				<td>/classroom/student[age<=20]</td>
				<td>选取classroom元素的所有student元素,且其中的age元素的值须小于等于20</td>
			</tr>
			<tr>
				<td>&gt;</td>
				<td>大于</td>
				<td>/classroom/student[age>20]</td>
				<td>选取classroom元素的所有student元素,且其中的age元素的值须大于20</td>
			</tr>
			<tr>
				<td>>=</td>
				<td>大于等于</td>
				<td>/classroom/student[age>=20]</td>
				<td>选取classroom元素的所有student元素,且其中的age元素的值须大于等于20</td>
			</tr>
			<tr>
				<td>or</td>
				<td>或</td>
				<td>/classroom/student[age<20 or age>25]</td>
				<td>选取classroom元素的所有student元素,且其中的age元素的值须小于20或大于25</td>
			</tr>		
			<tr>
				<td>and</td>
				<td>与</td>
				<td>/classroom/student[age>20 and age<25]</td>
				<td>选取classroom元素的所有student元素,且其中的age元素的值须大于20且小于25</td>
			</tr>	
			<tr>
				<td>mod</td>
				<td>计算除法的余数</td>
				<td>5 mod 2</td>
				<td>1</td>
			</tr>
		</table>
		
	</div>
</body>
</html>